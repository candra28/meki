-- Dev Tools LocalScript for Roblox (Place in StarterPlayerScripts)
-- Features:
-- Teleport (coords / checkpoints / saved coords)
-- Fly (toggle + adjustable speed + hotkey F)
-- Teleport to player
-- Infinity Jump
-- WalkSpeed slider
-- God Mode
-- Anti-AFK
-- Fling
-- Anti Fog
-- Auto-detect checkpoints (folder name "Checkpoints" by default)
-- Record coordinates (save to Rayfield config)
-- Auto-Walk (Pathfinding) with start/stop + hotkey G
-- Notifications via Rayfield
-- NOTE: Intended for use in YOUR OWN game (Roblox Studio). Do NOT use to exploit other games.

-- === CONFIG ===
local CHECKPOINT_FOLDER_NAME = "Checkpoints" -- change if your folder has a different name
local RAYFIELD_URL = "https://sirius.menu/rayfield" -- adjust if you host Rayfield locally
local RAYFIELD_WINDOW_NAME = "Dark HUB"
local CONFIG_FOLDER = "DarkHub"
local CONFIG_FILENAME = "DarkHubConfig"

-- === SERVICES & LOCALS ===
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Lighting = game:GetService("Lighting")
local VirtualUser = game:GetService("VirtualUser")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local function refreshCharacter()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end
LocalPlayer.CharacterAdded:Connect(refreshCharacter)

-- helper to safe-find HRP / Humanoid
local function getHRP()
    refreshCharacter()
    return Character and Character:FindFirstChild("HumanoidRootPart")
end
local function getHumanoid()
    refreshCharacter()
    return Character and Character:FindFirstChildOfClass("Humanoid")
end

-- === BASIC TELEPORT FUNCTIONS ===
local function teleportToVector3(v3)
    local hrp = getHRP()
    if hrp then hrp.CFrame = CFrame.new(v3) end
end
local function teleportToCoords(x,y,z) teleportToVector3(Vector3.new(x,y,z)) end

local function findPlayerByName(partial)
    if not partial then return nil end
    partial = partial:lower()
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            if plr.Name:lower():find(partial) or (plr.DisplayName and plr.DisplayName:lower():find(partial)) then
                return plr
            end
        end
    end
    return nil
end

local function teleportToPlayer(target)
    if typeof(target) == "string" then target = findPlayerByName(target) end
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local tHRP = target.Character.HumanoidRootPart
        local hrp = getHRP()
        if hrp then hrp.CFrame = tHRP.CFrame + Vector3.new(0,3,0) end
    end
end

-- === FLY (BodyVelocity + BodyGyro) ===
local flying = false
local flySpeed = 100
local flyBV, flyBG = nil, nil
local flightBindings = {Forward=0,Backward=0,Left=0,Right=0,Up=0,Down=0}

local function startFly(speed)
    if flying then return end
    flying = true
    flySpeed = speed or flySpeed
    local hrp = getHRP()
    if not hrp then return end
    if flyBV then flyBV:Destroy() end
    if flyBG then flyBG:Destroy() end
    flyBV = Instance.new("BodyVelocity")
    flyBV.MaxForce = Vector3.new(9e9,9e9,9e9)
    flyBV.P = 1250
    flyBV.Parent = hrp
    flyBG = Instance.new("BodyGyro")
    flyBG.MaxTorque = Vector3.new(9e9,9e9,9e9)
    flyBG.CFrame = hrp.CFrame
    flyBG.Parent = hrp

    spawn(function()
        while flying and hrp and hrp.Parent do
            local cam = workspace.CurrentCamera
            local forward = cam.CFrame.lookVector * (flightBindings.Forward - flightBindings.Backward)
            local right = cam.CFrame.rightVector * (flightBindings.Right - flightBindings.Left)
            local vertical = Vector3.new(0, (flightBindings.Up - flightBindings.Down), 0)
            local moveVec = (forward + right + vertical)
            if moveVec.Magnitude > 0 then
                flyBV.Velocity = moveVec.Unit * flySpeed
                flyBG.CFrame = CFrame.new(hrp.Position, hrp.Position + cam.CFrame.lookVector)
            else
                flyBV.Velocity = Vector3.new(0,0,0)
            end
            RunService.Heartbeat:Wait()
        end
        if flyBV and flyBV.Parent then flyBV:Destroy() end
        if flyBG and flyBG.Parent then flyBG:Destroy() end
        flyBV, flyBG = nil, nil
    end)
end

local function stopFly()
    flying = false
    if flyBV and flyBV.Parent then flyBV:Destroy() end
    if flyBG and flyBG.Parent then flyBG:Destroy() end
    flyBV, flyBG = nil, nil
end

-- flight input handling
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.W then flightBindings.Forward = 1 end
    if input.KeyCode == Enum.KeyCode.S then flightBindings.Backward = 1 end
    if input.KeyCode == Enum.KeyCode.A then flightBindings.Left = 1 end
    if input.KeyCode == Enum.KeyCode.D then flightBindings.Right = 1 end
    if input.KeyCode == Enum.KeyCode.Space then flightBindings.Up = 1 end
    if input.KeyCode == Enum.KeyCode.LeftControl then flightBindings.Down = 1 end
end)
UserInputService.InputEnded:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.W then flightBindings.Forward = 0 end
    if input.KeyCode == Enum.KeyCode.S then flightBindings.Backward = 0 end
    if input.KeyCode == Enum.KeyCode.A then flightBindings.Left = 0 end
    if input.KeyCode == Enum.KeyCode.D then flightBindings.Right = 0 end
    if input.KeyCode == Enum.KeyCode.Space then flightBindings.Up = 0 end
    if input.KeyCode == Enum.KeyCode.LeftControl then flightBindings.Down = 0 end
end)

-- === INFINITY JUMP ===
local infJump = false
UserInputService.JumpRequest:Connect(function()
    if infJump then
        local humanoid = getHumanoid()
        if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end
    end
end)

-- === WALKSPEED ===
local function setWalkSpeed(value)
    local humanoid = getHumanoid()
    if humanoid then humanoid.WalkSpeed = value end
end

-- === GOD MODE ===
local godEnabled = false
local godConns = {}
local function enableGod()
    local humanoid = getHumanoid()
    if not humanoid then return end
    godEnabled = true
    humanoid.MaxHealth = math.huge
    humanoid.Health = math.huge
    table.insert(godConns, humanoid.HealthChanged:Connect(function()
        if godEnabled then
            pcall(function() humanoid.Health = humanoid.MaxHealth end)
        end
    end))
    table.insert(godConns, humanoid.Died:Connect(function()
        if godEnabled then
            wait(0.5); refreshCharacter()
            local h = getHumanoid()
            if h then h.MaxHealth = math.huge; h.Health = math.huge end
        end
    end))
end
local function disableGod()
    godEnabled = false
    for _, c in ipairs(godConns) do pcall(function() c:Disconnect() end) end
    godConns = {}
    local humanoid = getHumanoid()
    if humanoid then humanoid.MaxHealth = 100; humanoid.Health = 100 end
end

-- === ANTI-AFK ===
local antiAfkEnabled = false
local antiAfkConn = nil
local function enableAntiAfk()
    if antiAfkEnabled then return end
    antiAfkEnabled = true
    antiAfkConn = LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton1(Vector2.new(0,0))
    end)
end
local function disableAntiAfk()
    antiAfkEnabled = false
    if antiAfkConn and antiAfkConn.Disconnect then pcall(function() antiAfkConn:Disconnect() end) end
    antiAfkConn = nil
end

-- === FLING ===
local function flingPlayer(target, forceMul)
    forceMul = forceMul or 200
    if typeof(target) == "string" then target = findPlayerByName(target) end
    if not target or not target.Character then return end
    local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
    local hrp = getHRP()
    if not tHRP or not hrp then return end
    local dir = (tHRP.Position - hrp.Position).Unit
    local vel = dir * forceMul
    for i=1,5 do
        hrp.Velocity = vel
        RunService.Stepped:Wait()
    end
end

-- === ANTI FOG ===
local originalFog = {Start = Lighting.FogStart or 0, End = Lighting.FogEnd or 100000}
local function enableAntiFog() Lighting.FogStart = 0; Lighting.FogEnd = 1e6 end
local function disableAntiFog() Lighting.FogStart = originalFog.Start; Lighting.FogEnd = originalFog.End end

-- === CHECKPOINT AUTO-DETECT ===
local checkpointFolder = workspace:FindFirstChild(CHECKPOINT_FOLDER_NAME)
local checkpointParts = {}
local CPDropdownValue = nil -- store selection if Rayfield dropdown lacks getter

local function refreshCheckpoints()
    checkpointParts = {}
    local folder = workspace:FindFirstChild(CHECKPOINT_FOLDER_NAME)
    if folder then
        for _, obj in ipairs(folder:GetChildren()) do
            if obj:IsA("BasePart") then table.insert(checkpointParts, obj) end
        end
    else
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and string.find(obj.Name:lower(), "checkpoint") then table.insert(checkpointParts, obj) end
        end
    end
end
refreshCheckpoints()

-- === SAVED COORDINATES & AUTO WALK (Pathfinding) ===
local savedCoords = {}
local savedCoordNames = {}
local savedCoordSelection = nil

local autoWalking = false
local autoWalkCancel = false
local function walkToPosition(targetPos)
    local char = LocalPlayer.Character
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return false end
    local path = PathfindingService:CreatePath({AgentRadius=2,AgentHeight=5,AgentCanJump=true})
    path:ComputeAsync(hrp.Position, targetPos)
    if path.Status ~= Enum.PathStatus.Success then return false end
    autoWalking = true; autoWalkCancel = false
    for _, wp in ipairs(path:GetWaypoints()) do
        if autoWalkCancel then break end
        if wp.Action == Enum.PathWaypointAction.Jump then humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end
        local done = false
        local conn = humanoid.MoveToFinished:Connect(function(reached) done = true end)
        humanoid:MoveTo(wp.Position)
        while not done and not autoWalkCancel do RunService.Heartbeat:Wait() end
        if conn then conn:Disconnect() end
        if autoWalkCancel then break end
    end
    autoWalking = false
    return not autoWalkCancel
end

local function startAutoWalkTo(position)
    if autoWalking then return end
    spawn(function()
        local ok = walkToPosition(position)
        if ok then
            if Rayfield and Rayfield.Notify then Rayfield:Notify({Title = \"Auto Walk\", Content = \"Selesai\", Duration = 4}) end
        else
            if Rayfield and Rayfield.Notify then Rayfield:Notify({Title = \"Auto Walk\", Content = \"Gagal (pathfinding)\", Duration = 4}) end
        end
    end)
end
local function stopAutoWalk() autoWalkCancel = true; autoWalking = false end

-- === RAYFIELD GUI LOAD & BUILD ===
local success, Rayfield = pcall(function() return loadstring(game:HttpGet(RAYFIELD_URL))() end)
if not success or type(Rayfield) ~= "table" then
    warn("Rayfield not found or failed to load. Make sure Rayfield is available at the configured URL.")
    Rayfield = nil
end

if Rayfield then
    local Window = Rayfield:CreateWindow({
        Name = RAYFIELD_WINDOW_NAME,
        LoadingTitle = "Init",
        LoadingSubtitle = "Dev Tools",
        ConfigurationSaving = {Enabled = true, FolderName = CONFIG_FOLDER, FileName = CONFIG_FILENAME},
        KeySystem = false
    })

    -- Tabs
    local TeleportTab = Window:CreateTab("Teleport")
    local MovementTab = Window:CreateTab("Movement")
    local MiscTab = Window:CreateTab("Misc")

    -- Teleport Tab - Coordinates Input
    TeleportTab:CreateInput({Name = "Teleport coordinates (x,y,z)", PlaceholderText = "e.g. 100,50,-200", RemoveTextAfterFocusLost = true, Callback = function(val)
        local parts = {}
        for p in val:gmatch('[^,]+') do table.insert(parts, p) end
        if #parts >= 3 then
            local xx = tonumber(parts[1]:gsub('%s+','')) or 0
            local yy = tonumber(parts[2]:gsub('%s+','')) or 0
            local zz = tonumber(parts[3]:gsub('%s+','')) or 0
            teleportToCoords(xx, yy, zz)
        end
    end})

    -- Teleport Tab - Players Dropdown
    local playerOptions = {}
    local selectedPlayer = nil
    local function refreshPlayerOptions()
        playerOptions = {}
        for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then table.insert(playerOptions, p.Name) end end
    end
    refreshPlayerOptions()
    TeleportTab:CreateDropdown({Name = "Choose player", Options = playerOptions, MultiSelect = false, Callback = function(opt) selectedPlayer = opt end})
    TeleportTab:CreateButton({Name = "Teleport to selected player", Callback = function() if selectedPlayer then teleportToPlayer(selectedPlayer) end end})

    -- Teleport Tab - Checkpoints Dropdown + Buttons
    local cpNames = {}
    for _, cp in ipairs(checkpointParts) do table.insert(cpNames, cp.Name) end
    local CPDropdown = TeleportTab:CreateDropdown({Name = "Pilih Checkpoint", Options = cpNames, MultiSelect = false, Callback = function(opt) CPDropdownValue = opt end})
    TeleportTab:CreateButton({Name = "Teleport to selected checkpoint", Callback = function()
        local sel = CPDropdownValue or (checkpointParts[1] and checkpointParts[1].Name)
        if sel then for _, cp in ipairs(checkpointParts) do if cp.Name == sel then teleportToVector3(cp.Position) break end end end
    end})
    TeleportTab:CreateButton({Name = "Auto Walk to selected checkpoint", Callback = function()
        local sel = CPDropdownValue or (checkpointParts[1] and checkpointParts[1].Name)
        if sel then for _, cp in ipairs(checkpointParts) do if cp.Name == sel then startAutoWalkTo(cp.Position); break end end end
    end})
    TeleportTab:CreateButton({Name = "Refresh Checkpoints", Callback = function() refreshCheckpoints(); local new = {}; for _, c in ipairs(checkpointParts) do table.insert(new, c.Name) end; CPDropdown:SetOptions(new) end})

    -- Saved Coordinates UI
    local savedCoordsDropdown = TeleportTab:CreateDropdown({Name = "Saved Coordinates", Options = savedCoordNames, MultiSelect = false, Callback = function(opt) savedCoordSelection = opt end})
    TeleportTab:CreateButton({Name = "Record Koordinat (Auto name)", Callback = function()
        local name = "Pos"..tostring(#savedCoordNames+1)
        local hrp = getHRP()
        if hrp then savedCoords[name] = hrp.Position; table.insert(savedCoordNames, name); savedCoordsDropdown:SetOptions(savedCoordNames) end
    end})
    TeleportTab:CreateInput({Name = "Record Koordinat (Custom Name)", PlaceholderText = "Masukkan nama posisi...", RemoveTextAfterFocusLost = true, Callback = function(val)
        if val and val ~= "" then local hrp = getHRP(); if hrp then savedCoords[val] = hrp.Position; table.insert(savedCoordNames, val); savedCoordsDropdown:SetOptions(savedCoordNames) end end
    end})
    TeleportTab:CreateButton({Name = "Teleport ke Saved Coordinate", Callback = function()
        local sel = savedCoordSelection or savedCoordNames[#savedCoordNames]
        if sel and savedCoords[sel] then teleportToVector3(savedCoords[sel]) end
    end})
    TeleportTab:CreateButton({Name = "Auto Walk to Saved Coordinate", Callback = function()
        local sel = savedCoordSelection or savedCoordNames[#savedCoordNames]
        if sel and savedCoords[sel] then startAutoWalkTo(savedCoords[sel]) end
    end})
    TeleportTab:CreateButton({Name = "Stop Auto Walk", Callback = function() stopAutoWalk() end})
    TeleportTab:CreateButton({Name = "Clear Saved Coordinates", Callback = function() savedCoords = {}; savedCoordNames = {}; savedCoordsDropdown:SetOptions(savedCoordNames) end})

    -- Movement Tab
    MovementTab:CreateSlider({Name = "WalkSpeed", Range = {16,400}, Increment = 1, CurrentValue = 16, Callback = function(val) setWalkSpeed(val) end})
    MovementTab:CreateToggle({Name = "Infinity Jump", CurrentValue = false, Callback = function(val) infJump = val end})
    MovementTab:CreateSlider({Name = "Fly Speed", Range = {10,1000}, Increment = 1, CurrentValue = flySpeed, Callback = function(val) flySpeed = val end})
    local flyToggle = MovementTab:CreateToggle({Name = "Fly (toggle)", CurrentValue = false, Callback = function(val) if val then startFly(flySpeed) else stopFly() end end})
    MovementTab:CreateToggle({Name = "God Mode", CurrentValue = false, Callback = function(val) if val then enableGod() else disableGod() end end})
    MovementTab:CreateToggle({Name = "Anti AFK", CurrentValue = false, Callback = function(val) if val then enableAntiAfk() else disableAntiAfk() end end})
    MovementTab:CreateButton({Name = "Fling Selected Player", Callback = function()
        local sel = selectedPlayer
        if sel then local p = findPlayerByName(sel); if p then flingPlayer(p, 300) end end
    end})

    -- Misc Tab (anti fog / config / hotkeys)
    MiscTab:CreateToggle({Name = "Anti Fog", CurrentValue = false, Callback = function(val) if val then enableAntiFog() else disableAntiFog() end end})
    MiscTab:CreateButton({Name = "Refresh Players List", Callback = function() refreshPlayerOptions(); -- find dropdown in TeleportTab not directly accessible in Rayfield default UI; reload window if needed end})

    -- Hotkeys: F = Fly toggle, G = Auto Walk toggle (to selected saved coord or last saved)
    UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.F then
            flyToggle:SetValue(not flyToggle.Flags.Value) -- try to flip the Rayfield toggle if available
            if not flyToggle.Flags.Value then startFly(flySpeed) else stopFly() end
        elseif input.KeyCode == Enum.KeyCode.G then
            -- toggle auto-walk to selected saved coord (or last saved)
            local sel = savedCoordSelection or savedCoordNames[#savedCoordNames]
            if sel and savedCoords[sel] then
                if autoWalking then stopAutoWalk() else startAutoWalkTo(savedCoords[sel]) end
            end
        end
    end)

    Window:RefreshAll()
end

-- End of script
